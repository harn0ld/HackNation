<!DOCTYPE html>
<html lang="pl">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>MapLibre – Miejsca z bazy</title>
    <link
      rel="stylesheet"
      href="https://unpkg.com/maplibre-gl@3.6.0/dist/maplibre-gl.css"
    />
    <style>
      html,
      body {
        margin: 0;
        height: 100%;
        min-height: 100dvh;
        font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont,
          "Segoe UI", sans-serif;
        background: #0f172a;
        color: #f1f5f9;
      }

      #map {
        position: fixed;
        inset: 0;
        width: 100%;
        height: 100%;
      }

      .maplibregl-ctrl {
        border-radius: 12px;
        overflow: hidden;
      }

      .maplibregl-popup-content {
        color: #0f172a;
      }

      .maplibregl-popup-content strong {
        color: #000;
      }

      .maplibregl-ctrl-top-right {
        margin: 12px;
      }

      #status {
        position: absolute;
        z-index: 2;
        top: 16px;
        left: 16px;
        padding: 10px 14px;
        border-radius: 10px;
        background: rgba(15, 23, 42, 0.85);
        color: #f8fafc;
        font-size: 0.85rem;
        box-shadow: 0 12px 32px rgba(15, 23, 42, 0.35);
        max-width: min(360px, calc(100% - 32px));
        line-height: 1.35;
        pointer-events: none;
      }

      @media (max-width: 640px) {
        #status {
          top: auto;
          bottom: 16px;
          left: 50%;
          transform: translateX(-50%);
          width: calc(100% - 32px);
          font-size: 0.78rem;
          padding: 8px 10px;
          text-align: center;
        }

        .maplibregl-ctrl-top-right {
          top: auto;
          bottom: 90px;
          right: 12px;
        }
      }

      @media (max-width: 480px) {
        .maplibregl-ctrl-group button {
          width: 34px;
          height: 34px;
        }
        .maplibregl-ctrl-geolocate {
          width: 44px;
          height: 44px;
        }
      }

      .marker-monument {
        width: 34px;
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      .marker-monument-body {
        width: 34px;
        height: 34px;
        border-radius: 999px;
        background: #fff;
        border: 2px solid #7c3aed;
        box-shadow: 0 8px 16px rgba(68, 51, 122, 0.35);
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .marker-monument-tail {
        width: 0;
        height: 0;
        border-left: 8px solid transparent;
        border-right: 8px solid transparent;
        border-top: 10px solid #7c3aed;
        margin-top: -1px;
      }

      .marker-monument svg {
        width: 16px;
        height: 16px;
        fill: #1f2937;
      }

      #llm-panel {
        position: absolute;
        right: 16px;
        top: 16px;
        width: min(360px, calc(100% - 32px));
        max-height: calc(100% - 32px);
        padding: 16px;
        border-radius: 16px;
        background: rgba(15, 23, 42, 0.92);
        color: #f8fafc;
        box-shadow: 0 20px 45px rgba(15, 23, 42, 0.45);
        display: flex;
        flex-direction: column;
        gap: 12px;
        overflow: hidden;
        z-index: 3;
        backdrop-filter: blur(8px);
      }

      #llm-panel h2 {
        margin: 0;
        font-size: 1.2rem;
      }

      #llm-status {
        font-size: 0.85rem;
        color: #cbd5f5;
        margin: 0;
      }

      #llm-current-place {
        font-size: 0.95rem;
        font-weight: 600;
      }

      #llm-output {
        flex: 1;
        border-radius: 12px;
        background: rgba(15, 23, 42, 0.65);
        border: 1px solid rgba(248, 250, 252, 0.1);
        padding: 12px;
        margin: 0;
        overflow-y: auto;
        font-family: "Inter", system-ui, sans-serif;
        font-size: 0.92rem;
        white-space: pre-wrap;
      }

      @media (max-width: 900px) {
        #llm-panel {
          position: static;
          width: 100%;
          max-height: none;
          margin: 16px;
        }
      }

      #pose-controls {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }

      #pose-toggle {
        border: none;
        border-radius: 10px;
        background: linear-gradient(135deg, #7c3aed, #a855f7);
        color: #fff;
        font-weight: 600;
        font-size: 0.95rem;
        padding: 10px 14px;
        cursor: pointer;
      }

      #pose-toggle[disabled] {
        opacity: 0.6;
        cursor: not-allowed;
      }

      #pose-feedback {
        margin: 0;
        font-size: 0.85rem;
        color: #cbd5f5;
        min-height: 2.5rem;
      }

    </style>
  </head>
  <body>
    <div id="status">Ładuję miejsca…</div>
    <div id="llm-panel">
      <div>
        <h2>Przewodnik AI</h2>
        <p id="llm-status">Rozpoczynam ładowanie modelu…</p>
      </div>
      <div id="llm-current-place">Wybierz lokalizację na mapie.</div>
      <pre id="llm-output">Jeszcze nic nie wygenerowano.</pre>
      <div id="pose-controls">
        <button id="pose-toggle">Aktywuj tryb mobilny</button>
        <p id="pose-feedback">Tryb mobilny nieaktywny.</p>
      </div>
    </div>
    <div id="map"></div>
    <script src="https://unpkg.com/maplibre-gl@3.6.0/dist/maplibre-gl.js"></script>
    <script type="module">
      const LLM_LOCAL_ASSET_BASE = new URL("../llm-html/", import.meta.url)
        .href.replace(/\/$/, "");
      const LLM_REMOTE_ASSET_BASE = "https://hn-test.netlify.app/llm-html";
      const MODEL_SOURCES = [
        {
          label: "lokalnej kopii",
          url: `${LLM_LOCAL_ASSET_BASE}/gemma-3-270m-it.Q4_K_M.gguf`,
        },
        {
          label: "kopii zapasowej",
          url: `${LLM_REMOTE_ASSET_BASE}/gemma-3-270m-it.Q4_K_M.gguf`,
          corsProxy: "https://cors.isomorphic-git.org/",
        },
      ];
      const { Wllama } = await import(`${LLM_LOCAL_ASSET_BASE}/esm/index.js`);

      const CONFIG_PATHS = {
        "single-thread/wllama.wasm": `${LLM_LOCAL_ASSET_BASE}/esm/single-thread/wllama.wasm`,
        "multi-thread/wllama.wasm": `${LLM_LOCAL_ASSET_BASE}/esm/multi-thread/wllama.wasm`,
      };

      const statusEl = document.getElementById("llm-status");
      const currentPlaceEl = document.getElementById("llm-current-place");
      const outputEl = document.getElementById("llm-output");

      class BrowserGuideLLM {
        constructor() {
          this.wllama = null;
          this.modelReady = false;
          this.isGenerating = false;
          this.pendingPlace = null;
          this.initialize();
        }

        async initialize() {
          try {
            for (const source of MODEL_SOURCES) {
              statusEl.textContent = `Ładuję model przewodnika (${source.label})…`;
              try {
                await this.loadModelFromSource(source);
                this.modelReady = true;
                statusEl.textContent =
                  "Model gotowy. Kliknij punkt na mapie, aby wygenerować narrację.";
                return;
              } catch (error) {
                console.error(`Nie udało się załadować ${source.label}:`, error);
              }
            }
            statusEl.textContent =
              "Błąd ładowania modelu – odśwież stronę lub sprawdź połączenie.";
          } catch (error) {
            console.error("Nie udało się załadować modelu LLM:", error);
            statusEl.textContent =
              "Błąd ładowania modelu – odśwież stronę lub sprawdź połączenie.";
          }
        }

        async loadModelFromSource(source) {
          const resolvedUrl = this.resolveModelUrl(source);
          const candidate = new Wllama(CONFIG_PATHS);
          try {
            await candidate.loadModelFromUrl(resolvedUrl);
          } catch (error) {
            if (this.shouldResetCache(error)) {
              await candidate.modelManager.clear().catch((clearError) => {
                console.warn("Nie udało się wyczyścić pamięci OPFS:", clearError);
              });
              await candidate.loadModelFromUrl(resolvedUrl, { useCache: false });
            } else {
              await candidate.exit().catch(() => {});
              throw error;
            }
          }
          await this.replaceWllama(candidate);
        }

        resolveModelUrl(source) {
          if (source.corsProxy) {
            return `${source.corsProxy}${source.url}`;
          }
          return source.url;
        }

        async replaceWllama(instance) {
          if (this.wllama && this.wllama !== instance) {
            await this.wllama.exit().catch(() => {});
          }
          this.wllama = instance;
        }

        shouldResetCache(error) {
          const message = (error && error.message) || "";
          return (
            /invalid magic/i.test(message) ||
            /typed array length/i.test(message) ||
            /Error while loading model/i.test(message)
          );
        }

        describePlace(place, context = {}) {
          if (!place) return;
          this.pendingPlace = { place, context: context || {} };
          if (!this.modelReady) {
            statusEl.textContent = "Model nadal się ładuje – proszę czekać…";
            return;
          }
          if (!this.isGenerating) {
            void this.processQueue();
          }
        }

        async processQueue() {
          if (this.isGenerating || !this.pendingPlace || !this.modelReady) {
            return;
          }
          const currentTask = this.pendingPlace;
          this.pendingPlace = null;
          await this.generateForPlace(currentTask);
          if (this.pendingPlace) {
            await this.processQueue();
          }
        }

        buildPrompt(place, context = {}) {
          const description = place.description?.trim();
          const fallback = "Brak opisu w bazie, więc uzupełnij ciekawostkami z wiedzy ogólnej.";
          const contextLines = this.buildContextLines(place, context, description || fallback);
          return [
            "Jesteś przewodnikiem miejskim mówiącym po polsku.",
            "Wykorzystując poniższy opis źródłowy, stwórz 2-3 zdania barwnej, inspirującej narracji.",
            "W narracji przywołaj co najmniej dwa konkrety z danych (nazwa, lokalizacja, ciekawostka historyczna).",
            "Parafrazuj treści, zachowaj pozytywny ton i zakończ zaproszeniem, by podejść bliżej. Nie dodawaj żadnych nagłówków – zwróć samą historię.",
            "",
            "DANE:",
            ...contextLines,
            "",
            "Narracja:",
          ].join("\n");
        }

        buildContextLines(place, context, defaultDescription) {
          const lines = [];
          lines.push(`Nazwa: ${place.name ?? "Nieznane miejsce"}`);
          const location =
            place.raw?.Localization ||
            place.raw?.Localisation ||
            place.raw?.Address ||
            place.raw?.Location ||
            "";
          if (location) {
            lines.push(`Lokalizacja: ${location}`);
          }
          if (place.coordinates?.length === 2) {
            lines.push(`Koordynaty: ${place.coordinates[1].toFixed(6)}, ${place.coordinates[0].toFixed(6)}`);
          }
          const dbDescription =
            place.raw?.Description?.trim() ||
            place.raw?.Opis?.trim() ||
            place.description?.trim() ||
            "";
          lines.push(`Opis źródłowy: ${dbDescription || defaultDescription}`);
          if (place.raw?.Connected_Buildings) {
            lines.push(`Powiązane obiekty: ${place.raw.Connected_Buildings}`);
          }
          if (context.source === "pose_tracking") {
            if (typeof context.distance === "number") {
              lines.push(`Użytkownik stoi około ${context.distance.toFixed(0)} m od obiektu.`);
            }
            if (typeof context.bearing === "number") {
              lines.push(`Kierunek obiektu względem użytkownika: ${context.bearing.toFixed(0)}°.`);
            }
          }
          if (context.source === "map_click") {
            lines.push("Użytkownik wybrał to miejsce ręcznie na mapie.");
          }
          return lines;
        }

        extractGeneratedText(fullText, prompt) {
          if (!fullText) return "";
          if (prompt && fullText.startsWith(prompt)) {
            return fullText.slice(prompt.length);
          }
          return fullText;
        }

        async generateForPlace(task) {
          const { place, context } = task;
          this.isGenerating = true;
          currentPlaceEl.textContent = `Opisuję: ${place.name ?? "wybrane miejsce"}`;
          outputEl.textContent = "";
          statusEl.textContent = "Generuję opis…";
          const prompt = this.buildPrompt(place, context);
          if (!this.wllama) {
            statusEl.textContent = "Model nie jest gotowy – spróbuj ponownie.";
            return;
          }

          try {
            await this.wllama.createCompletion(prompt, {
              nPredict: 160,
              sampling: { temp: 0.6, top_k: 30, top_p: 0.8 },
              onNewToken: (_token, _piece, text) => {
                const generated = this.extractGeneratedText(text, prompt);
                const cleaned = this.formatNarrativeOutput(generated);
                outputEl.textContent = cleaned;
              },
            });
            statusEl.textContent = "Gotowe – kliknij inne miejsce, aby wygenerować nową podpowiedź.";
          } catch (error) {
            console.error("Błąd podczas generowania narracji:", error);
            statusEl.textContent = "Nie udało się wygenerować odpowiedzi. Spróbuj ponownie.";
            outputEl.textContent = "Ups, model napotkał problem.";
          } finally {
            this.isGenerating = false;
          }
        }

        formatNarrativeOutput(text) {
          if (!text) return "";
          const trimmed = text.trimStart();
          const withoutLabel = trimmed.replace(/^(Narrative|Narracja|Historia)\s*:?\s*/i, "");
          return withoutLabel.trimStart();
        }
      }

      window.llmGuide = new BrowserGuideLLM();
    </script>
    <script>
      const MAPTILER_KEY = "get_your_own_OpIi9ZULNHzrESv6T2vL"; // podmień na własny
      const currentOrigin = window.location.origin;
      const defaultBackend =
        window.location.protocol.startsWith("http") && window.location.port === "8000"
          ? currentOrigin
          : `${window.location.protocol === "file:" ? "http:" : window.location.protocol}//${
              window.location.hostname || "127.0.0.1"
            }:8000`;
      const API_BASE_URL = window.BACKEND_URL || defaultBackend;
      const OSRM_PROFILE = "walking";
      const OSRM_BASE_URL = `https://router.project-osrm.org/route/v1/${OSRM_PROFILE}`;
      const POINTS_ENDPOINT = `${API_BASE_URL}/points`;
      const ROUTE_GEOJSON_ENDPOINT = `${API_BASE_URL}/route-geojson`;
      const USER_PLACE_ID = "__user-location";
      const initialCenter = [21.0122, 52.2297]; // Warszawa
      const statusEl = document.getElementById("status");
      const poseToggleBtn = document.getElementById("pose-toggle");
      const poseFeedbackEl = document.getElementById("pose-feedback");
      const telemetryElems = {
        yaw: document.getElementById("pose-yaw"),
        pitch: document.getElementById("pose-pitch"),
        roll: document.getElementById("pose-roll"),
        heading: document.getElementById("pose-heading"),
        lat: document.getElementById("pose-lat"),
        lon: document.getElementById("pose-lon"),
      };
      const hasValidMaptilerKey =
        typeof MAPTILER_KEY === "string" &&
        MAPTILER_KEY.trim() !== "" &&
        !/get_your_own/i.test(MAPTILER_KEY);
      const DATA_BASE_URL = new URL(".", window.location.href);

      const faraCenter = [18.00168, 53.12324];
      const map = new maplibregl.Map({
        container: "map",
        style: `https://api.maptiler.com/maps/streets/style.json?key=${MAPTILER_KEY}`,
        center: initialCenter,
        zoom: 14,
        pitch: 60,
        bearing: -20,
        antialias: true,
      });

      const geolocateControl = new maplibregl.GeolocateControl({
        positionOptions: { enableHighAccuracy: true },
        fitBoundsOptions: { maxZoom: 17 },
        showUserLocation: true,
        trackUserLocation: true,
      });
      map.addControl(geolocateControl, "top-right");
      geolocateControl.on("geolocate", (event) => {
        userLocationCoords = [event.coords.longitude, event.coords.latitude];
        ensureUserPlaceEntry();
        upsertUserStartMarker(userLocationCoords);
        void maybeApplyUserRoute();
      });

      map.on("styleimagemissing", (event) => {
        if (map.hasImage(event.id)) return;
        const size = 32;
        const data = new Uint8Array(size * size * 4);
        for (let i = 0; i < size * size; i += 1) {
          const offset = i * 4;
          data[offset] = 139;
          data[offset + 1] = 92;
          data[offset + 2] = 246;
          data[offset + 3] = 255;
        }
        try {
          map.addImage(
            event.id,
            { width: size, height: size, data },
            { sdf: false, pixelRatio: 1 }
          );
        } catch (error) {
          console.warn("Nie udało się dodać zastępczej ikony:", event.id, error);
        }
      });

      const placesOfInterest = [];
      const placeLookup = new Map();
      let placeCounter = 0;
      let userLocationCoords = null;
      let poiRouteOrder = [];
      let userLocationMarker = null;
      let poseTrackingStopper = null;
      let poseHeadingDeg = null;
      let poseGeoPosition = null;
      let lastPoseNarratedId = null;
      let mapFittedToPlaces = false;
      const POSE_DISTANCE_THRESHOLD_METERS = 60;
      const POSE_DIRECTION_THRESHOLD_DEG = 35;

      function metersToLat(meters) {
        return meters / 110540;
      }

      function metersToLng(meters, latitude) {
        return meters / (111320 * Math.cos((latitude * Math.PI) / 180));
      }

      function buildRectangleAround(center, widthMeters, heightMeters) {
        const halfWidth = widthMeters / 2;
        const halfHeight = heightMeters / 2;
        const latOffset = metersToLat(halfHeight);
        const lngOffset = metersToLng(halfWidth, center[1]);
        return [
          [
            [center[0] - lngOffset, center[1] - latOffset],
            [center[0] + lngOffset, center[1] - latOffset],
            [center[0] + lngOffset, center[1] + latOffset],
            [center[0] - lngOffset, center[1] + latOffset],
            [center[0] - lngOffset, center[1] - latOffset],
          ],
        ];
      }

      function degToRad(value) {
        return (value * Math.PI) / 180;
      }

      function haversineDistanceMeters(lat1, lon1, lat2, lon2) {
        const R = 6371000;
        const dLat = degToRad(lat2 - lat1);
        const dLon = degToRad(lon2 - lon1);
        const a =
          Math.sin(dLat / 2) * Math.sin(dLat / 2) +
          Math.cos(degToRad(lat1)) *
            Math.cos(degToRad(lat2)) *
            Math.sin(dLon / 2) *
            Math.sin(dLon / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
      }

      function bearingBetweenCoords(origin, target) {
        const lat1 = degToRad(origin[1]);
        const lat2 = degToRad(target[1]);
        const deltaLon = degToRad(target[0] - origin[0]);
        const y = Math.sin(deltaLon) * Math.cos(lat2);
        const x =
          Math.cos(lat1) * Math.sin(lat2) -
          Math.sin(lat1) * Math.cos(lat2) * Math.cos(deltaLon);
        const bearing = (Math.atan2(y, x) * 180) / Math.PI;
        return (bearing + 360) % 360;
      }

      function angularDifferenceDeg(a, b) {
        return Math.abs((((a - b) % 360) + 540) % 360 - 180);
      }

      function updateStatus(message) {
        if (!statusEl) return;
        statusEl.textContent = message;
        statusEl.style.display = message ? "block" : "none";
      }


      function createMonumentMarkerElement(title) {
        const wrapper = document.createElement("div");
        wrapper.className = "marker-monument";
        wrapper.title = title ?? "Miejsce";

        const body = document.createElement("div");
        body.className = "marker-monument-body";
        body.innerHTML = `
          <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <path d="M9 3h6l.6 4H8.4L9 3zm-1 6h8l2 7H6l2-7zm-2.5 9h11l1 3h-13l1-3z" />
          </svg>
        `;

        const tail = document.createElement("div");
        tail.className = "marker-monument-tail";

        wrapper.appendChild(body);
        wrapper.appendChild(tail);
        return wrapper;
      }

      function clearFallbackRoute() {
        if (map.getLayer("fallback-route-layer")) {
          map.removeLayer("fallback-route-layer");
        }
        if (map.getSource("fallback-route")) {
          map.removeSource("fallback-route");
        }
      }

      function addPlaceMarker(place) {
        const coordinates = place.coordinates;
        if (!coordinates) return;

        const placeWithId = {
          ...place,
          coordinates,
          id: place.id ?? `place-${placeCounter++}`,
        };
        placesOfInterest.push(placeWithId);
        placeLookup.set(placeWithId.id, placeWithId);
        const markerElement = createMonumentMarkerElement(placeWithId.name);
        markerElement.addEventListener("click", () => {
          if (window.llmGuide) {
            window.llmGuide.describePlace(placeWithId, { source: "map_click" });
          }
        });

        new maplibregl.Marker({ element: markerElement, anchor: "bottom" })
          .setLngLat(coordinates)
          .setPopup(
            new maplibregl.Popup({ offset: 12 }).setHTML(
              `<strong>${placeWithId.name ?? "Miejsce"}</strong><br/>${
                placeWithId.description ?? ""
              }`
            )
          )
          .addTo(map);

      }

      function ensureUserPlaceEntry() {
        if (!userLocationCoords) return;
        placeLookup.set(USER_PLACE_ID, {
          id: USER_PLACE_ID,
          name: "Twoja lokalizacja",
          coordinates: userLocationCoords,
        });
      }

      function upsertUserStartMarker(coords) {
        if (!map || !coords) return;
        if (!userLocationMarker) {
          const el = document.createElement("div");
          el.className = "marker-user-start";
          userLocationMarker = new maplibregl.Marker({
            element: el,
            anchor: "center",
          });
        }
        userLocationMarker.setLngLat(coords).addTo(map);
      }

      function findPoseCandidate(position, headingDeg) {
        if (!position || headingDeg == null || !placesOfInterest.length) {
          return null;
        }
        let best = null;
        placesOfInterest.forEach((place) => {
          if (!place.coordinates) return;
          const dist = haversineDistanceMeters(
            position.lat,
            position.lon,
            place.coordinates[1],
            place.coordinates[0]
          );
          if (dist > POSE_DISTANCE_THRESHOLD_METERS) return;
          const bearing = bearingBetweenCoords(
            [position.lon, position.lat],
            place.coordinates
          );
          const diff = angularDifferenceDeg(headingDeg, bearing);
          if (diff > POSE_DIRECTION_THRESHOLD_DEG) return;
          if (!best || dist < best.distance) {
            best = { place, distance: dist, bearing, diff };
          }
        });
        return best;
      }

      function updatePoseMatch() {
        if (!poseFeedbackEl) return;
        if (!poseTrackingStopper) {
          poseFeedbackEl.textContent = "Tryb mobilny nieaktywny.";
          return;
        }
        if (poseHeadingDeg == null || !poseGeoPosition) {
          poseFeedbackEl.textContent =
            "Czekam na dane z czujników – pozwól na dostęp do orientacji i lokalizacji.";
          return;
        }
        const candidate = findPoseCandidate(poseGeoPosition, poseHeadingDeg);
        if (!candidate) {
          poseFeedbackEl.textContent =
            "W tym kierunku brak obiektu w zasięgu ok. 60 m – spróbuj podejść bliżej lub obróć telefon.";
          return;
        }
        poseFeedbackEl.textContent = `Celujesz w ${candidate.place.name} (~${candidate.distance.toFixed(
          0
        )} m).`;
        if (
          candidate.place.id &&
          candidate.place.id !== lastPoseNarratedId &&
          window.llmGuide
        ) {
          lastPoseNarratedId = candidate.place.id;
          window.llmGuide.describePlace(candidate.place, {
            source: "pose_tracking",
            distance: candidate.distance,
            bearing: candidate.bearing,
          });
        }
      }

      async function enablePoseTracking() {
        if (typeof DeviceOrientationEvent?.requestPermission === "function") {
          const granted = await DeviceOrientationEvent.requestPermission();
          if (granted !== "granted") {
            throw new Error("Brak zgody na orientację urządzenia.");
          }
        }
        if (typeof DeviceMotionEvent?.requestPermission === "function") {
          try {
            await DeviceMotionEvent.requestPermission();
          } catch (error) {
            console.warn("Nie udało się uzyskać zgody DeviceMotion:", error);
          }
        }
        if (!navigator.geolocation) {
          throw new Error("Geolokacja niedostępna w tej przeglądarce.");
        }
        const orientationHandler = (event) => {
          const heading =
            typeof event.webkitCompassHeading === "number"
              ? event.webkitCompassHeading
              : event.alpha == null
              ? null
              : (360 - event.alpha + 360) % 360;
          if (heading == null) {
            return;
          }
          poseHeadingDeg = heading;
          telemetryElems.heading && (telemetryElems.heading.textContent = `${heading.toFixed(0)}°`);
          if (telemetryElems.yaw && typeof event.alpha === "number") {
            telemetryElems.yaw.textContent = `${event.alpha.toFixed(1)}°`;
          }
          if (telemetryElems.pitch && typeof event.beta === "number") {
            telemetryElems.pitch.textContent = `${event.beta.toFixed(1)}°`;
          }
          if (telemetryElems.roll && typeof event.gamma === "number") {
            telemetryElems.roll.textContent = `${event.gamma.toFixed(1)}°`;
          }
          updatePoseMatch();
        };
        window.addEventListener("deviceorientation", orientationHandler, true);
        const geoWatchId = navigator.geolocation.watchPosition(
          (pos) => {
            poseGeoPosition = {
              lat: pos.coords.latitude,
              lon: pos.coords.longitude,
            };
            if (telemetryElems.lat) {
              telemetryElems.lat.textContent = pos.coords.latitude.toFixed(6);
            }
            if (telemetryElems.lon) {
              telemetryElems.lon.textContent = pos.coords.longitude.toFixed(6);
            }
            updatePoseMatch();
          },
          (error) => {
            console.warn("Geolocation error:", error);
          },
          { enableHighAccuracy: true }
        );
        return () => {
          window.removeEventListener(
            "deviceorientation",
            orientationHandler,
            true
          );
          navigator.geolocation.clearWatch(geoWatchId);
        };
      }

      async function startPoseTracking() {
        if (!poseToggleBtn) return;
        poseToggleBtn.disabled = true;
        poseFeedbackEl.textContent = "Proszę o pozwolenia na czujniki…";
        try {
          poseTrackingStopper = await enablePoseTracking();
          poseToggleBtn.textContent = "Wyłącz tryb mobilny";
          poseFeedbackEl.textContent =
            "Śledzę orientację – skieruj telefon w stronę obiektu, aby usłyszeć historię.";
        } catch (error) {
          console.error("Błąd podczas uruchamiania trybu mobilnego:", error);
          poseFeedbackEl.textContent = `Nie udało się uruchomić trybu mobilnego: ${
            error?.message || error
          }`;
          poseTrackingStopper = null;
        } finally {
          poseToggleBtn.disabled = false;
        }
      }

      function stopPoseTracking() {
        if (!poseTrackingStopper || !poseToggleBtn) return;
        try {
          poseTrackingStopper();
        } catch (error) {
          console.warn("Nie udało się zatrzymać śledzenia orientacji:", error);
        }
        poseTrackingStopper = null;
        poseHeadingDeg = null;
        poseGeoPosition = null;
        lastPoseNarratedId = null;
        poseToggleBtn.textContent = "Aktywuj tryb mobilny";
        poseFeedbackEl.textContent = "Tryb mobilny nieaktywny.";
      }

      poseToggleBtn?.addEventListener("click", () => {
        if (poseTrackingStopper) {
          stopPoseTracking();
        } else {
          void startPoseTracking();
        }
      });


      async function loadPointsFromBackend() {
        try {
          updateStatus("Pobieram miejsca z backendu…");
          const response = await fetch(POINTS_ENDPOINT, { cache: "no-store" });
          if (!response.ok) {
            throw new Error(`Błąd ${response.status}`);
          }
          const records = await response.json();
          placesOfInterest.length = 0;
          placeLookup.clear();

          if (!Array.isArray(records) || !records.length) {
            updateStatus("Brak miejsc w bazie backendu.");
            return;
          }

          const sequentialIds = [];
          records.forEach((record) => {
            if (
              typeof record?.lng !== "number" ||
              typeof record?.lat !== "number" ||
              Number.isNaN(record.lng) ||
              Number.isNaN(record.lat)
            ) {
              return;
            }
            addPlaceMarker({
              id: record.id,
              name: record.name || "Miejsce",
              description: record.description ?? "",
              coordinates: [record.lng, record.lat],
              raw: record,
            });
            if (record.id) {
              sequentialIds.push(record.id);
            }
          });
          poiRouteOrder = sequentialIds.filter((value) => typeof value === "string");

          if (placesOfInterest.length >= 2) {
            clearFallbackRoute();
            const usedRoadNetwork = await fetchAndDrawGeoRoute();
            if (usedRoadNetwork) {
              updateStatus("Trasa piesza ustawiona przez backend (optymalna).");
            } else {
              updateStatus("Brak trasy drogowej – spróbuj odświeżyć backend.");
            }
          } else {
            updateStatus("Dodano tylko jeden punkt – backend nie ma jak ustalić trasy.");
          }
          return;
        } catch (error) {
          console.error("Nie udało się pobrać miejsc:", error);
        }

        const fallbackWorked = await loadPointsFromCsvFallback();
        if (!fallbackWorked) {
          updateStatus("Nie udało się pobrać miejsc (backend i CSV niedostępne).");
        }
      }

      function parseSemicolonCsv(text) {
        const rows = [];
        let currentField = "";
        let currentRow = [];
        let insideQuotes = false;

        for (let i = 0; i < text.length; i += 1) {
          const char = text[i];
          if (char === '"') {
            if (insideQuotes && text[i + 1] === '"') {
              currentField += '"';
              i += 1;
            } else {
              insideQuotes = !insideQuotes;
            }
          } else if (char === ";" && !insideQuotes) {
            currentRow.push(currentField);
            currentField = "";
          } else if ((char === "\n" || char === "\r") && !insideQuotes) {
            if (char === "\r" && text[i + 1] === "\n") {
              i += 1;
            }
            if (currentField.length > 0 || currentRow.length > 0) {
              currentRow.push(currentField);
              rows.push(currentRow);
            }
            currentRow = [];
            currentField = "";
          } else {
            currentField += char;
          }
        }

        if (currentField.length > 0 || currentRow.length > 0) {
          currentRow.push(currentField);
          rows.push(currentRow);
        }

        if (!rows.length) return [];

        const headers = rows.shift().map((header) => header.trim().replace(/^\ufeff/, ""));
        return rows
          .filter((row) => row.some((value) => value && value.trim().length))
          .map((row) => {
            const entry = {};
            headers.forEach((header, idx) => {
              entry[header] = (row[idx] ?? "").trim();
            });
            return entry;
          });
      }

      async function loadPointsFromCsvFallback() {
        try {
          updateStatus("Wczytuję punkty z lokalnej bazy CSV…");
          const [lokResponse, dbResponse] = await Promise.all([
            fetch(new URL("lokalzacja.csv", DATA_BASE_URL), { cache: "no-store" }),
            fetch(new URL("database.csv", DATA_BASE_URL), { cache: "no-store" }),
          ]);

          if (!lokResponse.ok) {
            throw new Error(`Błąd ${lokResponse.status} przy pobieraniu lokalizacji.`);
          }

          const lokalizacjaRecords = parseSemicolonCsv(await lokResponse.text());
          const sequentialIds = [];
          placesOfInterest.length = 0;
          placeLookup.clear();

          lokalizacjaRecords.forEach((record, idx) => {
            const id = record.ID || record.Id || record.id || `lok_${idx + 1}`;
            const lat = parseFloat(record.x || record.X);
            const lng = parseFloat(record.y || record.Y);
            if (Number.isNaN(lat) || Number.isNaN(lng)) {
              return;
            }
            sequentialIds.push(id);
            addPlaceMarker({
              id,
              name: record.Localization || record.Localisation || `Localization ${idx + 1}`,
              coordinates: [lng, lat],
            });
          });

          if (dbResponse.ok) {
            const dbRecords = parseSemicolonCsv(await dbResponse.text());
            dbRecords.forEach((record, idx) => {
              const gpsId = record["GPS ID"] || record["gps id"] || "";
              const parts = gpsId
                .replace(";", ",")
                .split(",")
                .map((value) => value.trim())
                .filter(Boolean);
              if (parts.length !== 2) return;
              const lat = parseFloat(parts[0]);
              const lng = parseFloat(parts[1]);
              if (Number.isNaN(lat) || Number.isNaN(lng)) return;
              const id = record.id || record.Id || `db_${idx + 1}`;
              addPlaceMarker({
                id,
                name: record.Name || id,
                description: record.Description || "",
                coordinates: [lng, lat],
              });
            });
          }

          poiRouteOrder = sequentialIds.slice();

          let osrmFallbackUsed = false;
          if (sequentialIds.length >= 2) {
            osrmFallbackUsed = await drawFallbackDrivingRoute(sequentialIds);
          }

          if (!osrmFallbackUsed && sequentialIds.length >= 2) {
            drawSimplePath(sequentialIds);
            updateStatus("Brak backendu – pokazuję trasę z CSV (prosta linia).");
          } else if (!osrmFallbackUsed) {
            updateStatus("Brak backendu – dodano tylko jeden punkt z CSV.");
          }
          updatePoseMatch();

          return true;
        } catch (error) {
          console.error("Nie udało się pobrać danych z CSV:", error);
          return false;
        }
      }

      function drawSimplePath(sequence) {
        if (!Array.isArray(sequence) || sequence.length < 2) return;
        const coordinates = [];
        if (userLocationCoords) {
          coordinates.push([...userLocationCoords]);
        }
        sequence.forEach((identifier) => {
          const place = placeLookup.get(identifier);
          if (place?.coordinates) {
            coordinates.push(place.coordinates);
          }
        });
        if (coordinates.length < 2) return;

        const feature = {
          type: "Feature",
          geometry: {
            type: "LineString",
            coordinates,
          },
          properties: {},
        };

        if (!map.getSource("fallback-route")) {
          map.addSource("fallback-route", {
            type: "geojson",
            data: {
              type: "FeatureCollection",
              features: [feature],
            },
          });
          map.addLayer({
            id: "fallback-route-layer",
            type: "line",
            source: "fallback-route",
            layout: {
              "line-cap": "round",
              "line-join": "round",
            },
            paint: {
              "line-color": "#f97316",
              "line-width": 4,
            },
          });
        } else {
          map.getSource("fallback-route").setData({
            type: "FeatureCollection",
            features: [feature],
          });
        }

        const bounds = coordinates.reduce(
          (acc, coord) => {
            acc[0][0] = Math.min(acc[0][0], coord[0]);
            acc[0][1] = Math.min(acc[0][1], coord[1]);
            acc[1][0] = Math.max(acc[1][0], coord[0]);
            acc[1][1] = Math.max(acc[1][1], coord[1]);
            return acc;
          },
          [
            [Infinity, Infinity],
            [-Infinity, -Infinity],
          ]
        );

        if (Number.isFinite(bounds[0][0]) && Number.isFinite(bounds[1][0])) {
          map.fitBounds(bounds, { padding: 50, duration: 800 });
        }
      }

      function renderDrivingRoute(data) {
        const feature = data?.features?.[0];
        if (!feature?.geometry || feature.geometry.type !== "LineString") {
          return false;
        }

        const viaPoints = feature?.properties?.via_points;
        if (Array.isArray(viaPoints) && viaPoints.length) {
          poiRouteOrder = viaPoints.filter(
            (identifier) => identifier && identifier !== USER_PLACE_ID
          );
        }

        if (!map.getSource("driving-route-full")) {
          map.addSource("driving-route-full", {
            type: "geojson",
            data,
          });
          map.addLayer({
            id: "driving-route-full-layer",
            type: "line",
            source: "driving-route-full",
            layout: {
              "line-cap": "round",
              "line-join": "round",
            },
            paint: {
              "line-color": "#dc2626",
              "line-width": 5,
              "line-opacity": 0.9,
            },
          });
        } else {
          map.getSource("driving-route-full").setData(data);
        }

        const bounds = feature.geometry.coordinates.reduce(
          (acc, coord) => {
            acc[0][0] = Math.min(acc[0][0], coord[0]);
            acc[0][1] = Math.min(acc[0][1], coord[1]);
            acc[1][0] = Math.max(acc[1][0], coord[0]);
            acc[1][1] = Math.max(acc[1][1], coord[1]);
            return acc;
          },
          [
            [Infinity, Infinity],
            [-Infinity, -Infinity],
          ]
        );

        if (Number.isFinite(bounds[0][0]) && Number.isFinite(bounds[1][0])) {
          map.fitBounds(bounds, { padding: 60, duration: 800 });
        }

        if (feature?.properties?.source !== "osrm-user-route") {
          void maybeApplyUserRoute();
        }

        return true;
      }

      async function fetchAndDrawGeoRoute() {
        if (!ROUTE_GEOJSON_ENDPOINT) {
          return false;
        }

        try {
          const response = await fetch(ROUTE_GEOJSON_ENDPOINT, { cache: "no-store" });
          if (response.status === 404) {
            console.warn("Backend nie zwrócił jeszcze geometrii trasy (404).");
            return false;
          }
          if (!response.ok) {
            throw new Error(`Błąd ${response.status}`);
          }
          const data = await response.json();
          const rendered = renderDrivingRoute(data);
          if (!rendered) {
            console.warn("Nieprawidłowy kształt trasy w odpowiedzi backendu.");
          }
          return rendered;
        } catch (error) {
          console.error("Nie udało się pobrać trasy drogowej:", error);
          return false;
        }
      }

      async function fetchOsrmRoute(sequence, sourceLabel = "osrm-route") {
        const resolvedIds = [];
        const coordinates = [];
        sequence.forEach((identifier) => {
          const place = placeLookup.get(identifier);
          if (!place?.coordinates) return;
          resolvedIds.push(identifier);
          coordinates.push(place.coordinates);
        });
        if (coordinates.length < 2) {
          return null;
        }

        const coordinateString = coordinates.map((coord) => `${coord[0]},${coord[1]}`).join(";");

        try {
          const response = await fetch(
            `${OSRM_BASE_URL}/${coordinateString}?overview=full&geometries=geojson`
          );
          if (!response.ok) {
            return null;
          }
          const data = await response.json();
          const geometry = data?.routes?.[0]?.geometry;
          if (!geometry) {
            return null;
          }

          return {
            type: "FeatureCollection",
            features: [
              {
                type: "Feature",
                geometry,
                properties: {
                  source: sourceLabel,
                  via_points: resolvedIds,
                },
              },
            ],
          };
        } catch (error) {
          console.warn("Nie udało się pobrać trasy OSRM route:", error);
          return null;
        }
      }

      async function fetchOsrmSegment(start, end) {
        const url = `${OSRM_BASE_URL}/${start[0]},${start[1]};${end[0]},${end[1]}?overview=full&geometries=geojson`;
        const response = await fetch(url);
        if (!response.ok) {
          throw new Error(`OSRM error ${response.status}`);
        }
        const data = await response.json();
        return data.routes?.[0]?.geometry?.coordinates ?? null;
      }

      async function maybeApplyUserRoute() {
        if (!userLocationCoords || !poiRouteOrder.length) {
          return false;
        }
        ensureUserPlaceEntry();
        const sequence = [USER_PLACE_ID, ...poiRouteOrder];
        const routeData = await fetchOsrmRoute(sequence, "osrm-user-route");
        if (!routeData) {
          return false;
        }
        const rendered = renderDrivingRoute(routeData);
        if (rendered) {
          updateStatus("Trasa piesza od Twojej lokalizacji.");
        }
        return rendered;
      }

      async function drawFallbackDrivingRoute(sequence) {
        if (!Array.isArray(sequence) || sequence.length < 2) {
          return false;
        }

        ensureUserPlaceEntry();
        const sequenceWithUser = userLocationCoords
          ? [USER_PLACE_ID, ...sequence]
          : sequence.slice();

        const routeData = await fetchOsrmRoute(sequenceWithUser);
        if (routeData) {
          const renderedTrip = renderDrivingRoute(routeData);
          if (renderedTrip) {
            clearFallbackRoute();
            updateStatus("Trasa piesza (OSRM route – kolejność z CSV).");
            return true;
          }
        }

        const combined = [];
        for (let idx = 0; idx < sequence.length - 1; idx += 1) {
          const fromId = sequence[idx];
          const toId = sequence[idx + 1];
          const fromPlace = placeLookup.get(fromId);
          const toPlace = placeLookup.get(toId);
          if (!fromPlace?.coordinates || !toPlace?.coordinates) {
            continue;
          }

          try {
            const segment = await fetchOsrmSegment(fromPlace.coordinates, toPlace.coordinates);
            if (!Array.isArray(segment) || !segment.length) {
              continue;
            }

            if (!combined.length) {
              combined.push(...segment);
            } else if (
              combined[combined.length - 1][0] === segment[0][0] &&
              combined[combined.length - 1][1] === segment[0][1]
            ) {
              combined.push(...segment.slice(1));
            } else {
              combined.push(...segment);
            }
          } catch (error) {
            console.warn("Nie udało się pobrać fragmentu trasy z OSRM:", error);
          }
        }

        if (combined.length < 2) {
          return false;
        }

        const data = {
          type: "FeatureCollection",
          features: [
            {
              type: "Feature",
              geometry: {
                type: "LineString",
                coordinates: combined,
              },
              properties: {
                source: "osrm-fallback",
              },
            },
          ],
        };

        const rendered = renderDrivingRoute(data);
        if (rendered) {
          clearFallbackRoute();
          updateStatus("Trasa piesza po drogach (segmenty OSRM).");
        }
        return rendered;
      }

      map.on("load", () => {
        if (hasValidMaptilerKey) {
          map.addSource("terrain", {
            type: "raster-dem",
            url: `https://api.maptiler.com/tiles/terrain-rgb/tiles.json?key=${MAPTILER_KEY}`,
            tileSize: 256,
            maxzoom: 14,
          });
          map.setTerrain({ source: "terrain", exaggeration: 1.5 });
        } else {
          console.warn(
            "Pomijam warstwę terenu – podmień MAPTILER_KEY na własny, aby włączyć 3D terrain."
          );
        }

        const styleLayers = map.getStyle()?.layers || [];
        const buildingLayerExists = styleLayers.some(
          (layer) => layer.id === "building"
        );
        const waterwayReferenceLayer =
          styleLayers.find((layer) => layer.id === "waterway")?.id ||
          styleLayers.find((layer) => /water/i.test(layer.id))?.id;

        if (buildingLayerExists && waterwayReferenceLayer) {
          map.addLayer(
            {
              id: "3d-buildings",
              source: "openmaptiles",
              "source-layer": "building",
              filter: ["==", ["get", "extrude"], "true"],
              type: "fill-extrusion",
              minzoom: 13,
              paint: {
                "fill-extrusion-color": [
                  "interpolate",
                  ["linear"],
                  ["to-number", ["get", "height"], 20],
                  0,
                  "#d8d7d5",
                  200,
                  "#f8f4ef",
                ],
                "fill-extrusion-height": [
                  "interpolate",
                  ["linear"],
                  ["zoom"],
                  13,
                  0,
                  13.05,
                  [
                    "coalesce",
                    ["to-number", ["get", "render_height"]],
                    ["to-number", ["get", "height"]],
                    20,
                  ],
                ],
                "fill-extrusion-base": [
                  "coalesce",
                  ["to-number", ["get", "render_min_height"]],
                  ["to-number", ["get", "min_height"]],
                  0,
                ],
                "fill-extrusion-opacity": 0.9,
              },
            },
            waterwayReferenceLayer
          );
        } else {
          console.warn(
            "Pomijam dodatkową warstwę budynków 3D – nie znaleziono wymaganych warstw w stylu bazowym."
          );
        }

        // Custom footprint for the church
        const faraFootprint = {
          type: "Feature",
          properties: {
            height: 32,
            base: 0,
            name: "Bazylika św. Marcina i Mikołaja (Fara)",
          },
          geometry: {
            type: "Polygon",
            coordinates: buildRectangleAround(faraCenter, 32, 58),
          },
        };

        map.addSource("fara-model", {
          type: "geojson",
          data: {
            type: "FeatureCollection",
            features: [faraFootprint],
          },
        });

        map.addLayer({
          id: "fara-model-layer",
          type: "fill-extrusion",
          source: "fara-model",
          paint: {
            "fill-extrusion-color": "#c4b5fd",
            "fill-extrusion-base": ["get", "base"],
            "fill-extrusion-height": ["get", "height"],
            "fill-extrusion-opacity": 0.9,
          },
        });

        map.addLayer({
          id: "fara-label",
          type: "symbol",
          source: "fara-model",
          layout: {
            "text-field": ["get", "name"],
            "text-size": 12,
            "text-offset": [0, 2],
            "text-anchor": "top",
          },
          paint: {
            "text-color": "#3b0764",
            "text-halo-color": "#ffffff",
            "text-halo-width": 1.2,
          },
        });

        loadPointsFromCsvFallback();

        if (typeof geolocateControl.trigger === "function") {
          geolocateControl.once("error", (error) => {
            console.warn("Automatyczne pobranie lokalizacji nie powiodło się:", error);
            updateStatus(
              "Nie udało się automatycznie pobrać lokalizacji – kliknij przycisk GPS."
            );
          });
          geolocateControl.trigger();
        }
      });

      map.addControl(new maplibregl.NavigationControl(), "top-right");
    </script>
  </body>
</html>
